{
	"Custom C++ Template": {
		"prefix": "tp",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"#ifndef HARSHIT",
			"    #define debug(...) cout << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__);",
			"#else",
			"    #define debug(...);",
			"#endif",
			"template <typename T> std::ostream &operator<<(std::ostream &stream, const vector<T> &vec) { for (size_t i = 0; i < vec.size(); i++) { stream << vec[i]; if (i != vec.size() - 1) stream << ' '; } return stream; } template <typename T> std::istream &operator>>(std::istream &stream, vector<T> &vec) { for (T &x : vec) stream >> x; return stream; } template <typename T, typename U> std::ostream &operator<<(std::ostream &stream, const pair<T, U> &pr) { stream << pr.first << ' ' << pr.second; return stream; } template <typename T, typename U> std::istream &operator>>(std::istream &stream, pair<T, U> &pr) { stream >> pr.first >> pr.second; return stream; } template <typename A, typename B> string to_string(pair<A, B> p); template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p); template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p); string to_string(const string &s) { return '\"' + s + '\"'; } string to_string(char c) { string s; s += c; return s; } string to_string(const char *s) { return to_string((string)s); } string to_string(bool b) { return (b ? \"1\" : \"0\"); } string to_string(vector<bool> v) { bool first = true; string res = \"{ \"; for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += \", \"; } first = false; res += to_string(v[i]); } res += \" }\"; return res; } template <size_t N> string to_string(bitset<N> v) { string res = \"\"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; } template <typename A> string to_string(A v) { bool first = true; string res = \"{ \"; for (const auto &x : v) { if (!first) { res += \", \"; } first = false; res += to_string(x); } res += \" }\"; return res; } template <typename A, typename B> string to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; } template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\"; } template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p) { return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\"; } void debug_out() { cout << endl; } template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << \" \" << to_string(H); debug_out(T...); }",
			"",
			"#define int long long",
			"#define endl '\\n'",
			"# define Harshit  cin.tie(nullptr)->sync_with_stdio(false);",
			"#define X first",
			"#define Y second",
			"#define  V vector",
			"#define pb push_back",
			"",
			"const bool multipleTestCases = 1;",
			"const int mod = 1e9 + 7;",
			"",
			"void harshit()",
			"{",
			"    $1",
			"}",
			"",
			"signed main()",
			"{",
			"    Harshit",
			"    int t = 1;",
			"    multipleTestCases and cin >> t;",
			"    for (int i = 1; i <= t; i++)",
			"    {",
			"        // cout << \"Case #\" << i << \": \";",
			"        harshit();",
			"    }",
			"}"
		],
		"description": "Custom C++ template with debugging and utility functions"
	},
		"SegmentTree": {
			"prefix": "lzy",
			"body": [
				"class SegmentTree{",
				"    public:",
				"    vector<int> tree;",
				"    vector<bool> lazy;",
				"    vector<int> lazyValues;",
				"    int N;",
				"    SegmentTree(int n){",
				"        tree.resize(4*n);",
				"        lazy.resize(4*n);",
				"        lazyValues.resize(4*n);",
				"        N = n;",
				"    }",
				"",
				"    void propogate(int tid , int tl , int tr){",
				"        if(!lazy[tid]){",
				"            return;",
				"        }",
				"        if(tl != tr){",
				"            lazyValues[2*tid+1] += lazyValues[tid];",
				"            lazy[2*tid+1] = true;",
				"            lazyValues[2*tid+2] += lazyValues[tid];",
				"            lazy[2*tid+2] = true;",
				"        }",
				"        tree[tid] += lazyValues[tid];",
				"        lazyValues[tid] = 0;",
				"        lazy[tid] = false;",
				"    }",
				"",
				"    void update(int l , int r , int x){",
				"        function<void(int,int,int)> f = [&](int tid , int tl , int tr){",
				"            propogate(tid , tl , tr);",
				"            if(tl > r || tr < l){",
				"                return;",
				"            }",
				"            if(l <= tl && tr <= r){",
				"                lazy[tid] = true;",
				"                lazyValues[tid] += x;",
				"                propogate(tid , tl , tr);",
				"                return;",
				"            }",
				"            int tm = (tl + tr) / 2;",
				"            f(2*tid + 1, tl, tm);",
				"            f(2*tid + 2, tm + 1, tr);",
				"            tree[tid] = min(tree[2*tid + 1], tree[2*tid + 2]);",
				"        };",
				"        f(0, 0, N-1);",
				"    }",
				"",
				"    int query(int l , int r){",
				"        function<int(int,int,int)> f = [&](int tid , int tl , int tr){",
				"            propogate(tid , tl , tr);",
				"            if(tl > r || tr < l){",
				"                return INT_MAX;",
				"            }",
				"            if(l <= tl && tr <= r){",
				"                return tree[tid];",
				"            }",
				"            int tm = (tl + tr) / 2;",
				"            return min(f(2*tid + 1, tl, tm), f(2*tid + 2, tm + 1, tr));",
				"        };",
				"        return f(0, 0, N-1);",
				"    }",
				"};"
			],
			"description": "Segment Tree implementation with lazy propagation"
		},
			"SegmentTreeTemplate": {
				"prefix": "sgt",
				"body": [
					"class Node",
					"{",
					"public:",
					"    ",
					"};",
					"",
					"Node merge(Node a, Node b){",
					"    ",
					"    return ans;",
					"}",
					"",
					"template<typename T>",
					"class SegmentTree",
					"{",
					"public:",
					"    vector<T> tree;",
					"    T identity;",
					"    int N;",
					"",
					"    T merge(T a, T b)",
					"    {",
					"        return a + b;",
					"    }",
					"",
					"    SegmentTree(int n, T identity)",
					"    {",
					"        N = n;",
					"        this->identity = identity;",
					"        tree.assign(4 * N, identity);",
					"    }",
					"",
					"    // update a[qIdx] = val",
					"    void update(int qIdx, T val)",
					"    {",
					"        function<void(int, int, int)> f = [&](int tIdx, int tL, int tR)",
					"        {",
					"            if(tL == tR)",
					"            {",
					"                tree[tIdx] = val;",
					"                return;",
					"            }",
					"",
					"            int tM = (tL + tR) / 2;",
					"            if(tL <= qIdx && qIdx <= tM)",
					"            {",
					"                f(2*tIdx + 1, tL, tM);",
					"            }",
					"            else",
					"            {",
					"                f(2*tIdx + 2, tM + 1, tR);",
					"            }",
					"            tree[tIdx] = merge(tree[2*tIdx + 1], tree[2*tIdx + 2]);",
					"        };",
					"        f(0, 0, N - 1);",
					"    }",
					"",
					"    T query(int l, int r)",
					"    {",
					"        function<T(int, int, int)> f = [&](int tIdx, int tL, int tR)",
					"        {",
					"            // no overlap",
					"            if(l > tR || r < tL)",
					"            {",
					"                return identity;",
					"            }",
					"            // complete overlap",
					"            if(l <= tL && tR <= r)",
					"            {",
					"                return tree[tIdx];",
					"            }",
					"            // partial overlap",
					"            int tM = (tL + tR) / 2;",
					"            return merge(f(2*tIdx + 1, tL, tM), f(2*tIdx + 2, tM + 1, tR));",
					"        };",
					"        return f(0, 0, N - 1);",
					"    }",
					"};"
				],
				"description": "Templated Segment Tree with merge function and identity element"
			}
			,
				"HashClass": {
					"prefix": "hsh",
					"body": [
						"int power(int x , int n , int mod){",
						"    if(n==0){",
						"        return 1;",
						"    }",
						"    if(n%2==1){",
						"        return (power(x,n-1,mod)*x) % mod;",
						"    }",
						"    int ans = power(x , n/2 , mod);",
						"    return (ans*ans) % mod;",
						"}",
						"int modInv(int x , int mod){",
						"    return power(x , mod -2 , mod);",
						"}",
						"class Hash{",
						"    const int p1 = 31 , p2 = 37;",
						"    int mod1 = 1e9+7 , mod2 = 1e9+9;",
						"    vector<int> arr1 , arr2;",
						"    vector<int> modInv1 , modInv2;",
						"    public:",
						"        Hash(string &s){",
						"            int n = s.size();",
						"            arr1.resize(n);",
						"            arr2.resize(n);",
						"            modInv1.resize(n);",
						"            modInv2.resize(n);",
						"            int pow1 = 1 , pow2 = 1;",
						"            for(int i=0; i<n; i++){",
						"                arr1[i] = ((s[i]-'a' + 1) * pow1) % mod1;",
						"                arr2[i] = ((s[i]-'a' + 1) * pow2) % mod2;",
						"                pow1 *= p1;",
						"                pow1 %= mod1;",
						"                pow2 *= p2;",
						"                pow2 %= mod2;",
						"            }",
						"            for(int i=1; i<n; i++){",
						"                arr1[i] += arr1[i-1];",
						"                arr1[i] %= mod1;",
						"                arr2[i] += arr2[i-1];",
						"                arr2[i] %= mod2;",
						"            }",
						"            pow1 = modInv(p1, mod1);",
						"            pow2 = modInv(p2, mod2);",
						"            modInv1[0] = 1;",
						"            modInv2[0] = 1;",
						"            for(int i=1; i<n; i++){",
						"                modInv1[i] = (modInv1[i-1] * pow1) % mod1;",
						"                modInv2[i] = (modInv2[i-1] * pow2) % mod2;",
						"            }",
						"        }",
						"",
						"        pair<int,int> substr(int l , int r){",
						"            if(r >= arr1.size()){",
						"                return {-1, -1};",
						"            }",
						"            int ans1 = arr1[r] - (l ? arr1[l-1] : 0);",
						"            ans1 += mod1;",
						"            ans1 %= mod1;",
						"            int ans2 = arr2[r] - (l ? arr2[l-1] : 0);",
						"            ans2 += mod2;",
						"            ans2 %= mod2;",
						"            ans1 *= modInv1[l];",
						"            ans1 %= mod1;",
						"            ans2 *= modInv2[l];",
						"            ans2 %= mod2;",
						"            return {ans1, ans2};",
						"        }",
						"};"
					],
					"description": "String Hashing Class with Modulo and Power Functions"
				}
				,
		
					"SqrtDecomposition": {
						"prefix": "sqrd",
						"body": [
							"struct DECOMPOSITION{",
							"    vector<int> arr;",
							"    int n;",
							"    vector<int> sq;",
							"    int bs;",
							"    DECOMPOSITION(vector<int>& a){",
							"        arr = a;",
							"        n = arr.size();",
							"        bs = sqrt(n) + 1;",
							"        sq.resize(bs * bs);",
							"        for(int i = 0; i < n; i++){",
							"            sq[i] = arr[i];",
							"        }",
							"        for(int i = 0; i < n; i += bs){",
							"            int s = i;",
							"            int e = min((int)sq.size(), i + bs);",
							"            sort(sq.begin() + s, sq.begin() + e);",
							"        }",
							"    }",
							"",
							"    void update(int idx , int val){",
							"        arr[idx] = val;",
							"        int blockIdx = idx / bs;",
							"        int s = blockIdx * bs;",
							"        int e = min((int)sq.size(), s + bs);",
							"        for(int i = s; i < e; i++){",
							"            sq[i] = arr[i];",
							"        }",
							"        sort(sq.begin() + s, sq.begin() + e);",
							"    }",
							"",
							"    int query(int l , int r, int x){",
							"        int ans = 0;",
							"        for(int i = l; i <= r; ++i){",
							"            if(i % bs != 0 || i + bs - 1 > r){",
							"                if(arr[i] >= x){",
							"                    ans++;",
							"                }",
							"            }",
							"            else{",
							"                int s = i;",
							"                int e = i + bs - 1;",
							"                int idx = -1;",
							"                while(s <= e){",
							"                    int mid = (s + e) / 2;",
							"                    if(sq[mid] >= x){",
							"                        idx = mid;",
							"                        e = mid - 1;",
							"                    }",
							"                    else{",
							"                        s = mid + 1;",
							"                    }",
							"                }",
							"                if(idx != -1){",
							"                    ans += i + bs - idx;",
							"                }",
							"                i += bs - 1;",
							"            }",
							"        }",
							"        return ans;",
							"    }",
							"};"
						],
						"description": "Square Root Decomposition with Range Queries and Updates"
					},
						"EulerTour": {
							"prefix": "eul",
							"body": [
								"vector<int> tin(n), tout(n), tour, level(n);",
								"int timer = 0;",
								"function<void(int, int, int)> dfs = [&](int cur, int parent, int l) {",
								"    tin[cur] = timer++;",
								"    tour.push_back(cur);",
								"    level[cur] = l;",
								"    for (int nb : A[cur]) {",
								"        if (nb != parent) {",
								"            dfs(nb, cur, l + 1);",
								"        }",
								"    }",
								"    tour.push_back(cur);",
								"    tout[cur] = timer++;",
								"};"
							],
							"description": "Euler Tour with Entry and Exit Time Tracking"
						},
							"MosAlgorithm": {
								"prefix": "mos",
								"body": [
									"struct Query {",
									"    int l;",
									"    int r;",
									"    int id;",
									"};",
									"",
									"const int S = 700;",
									"",
									"bool cmp(Query A, Query B) {",
									"    if (A.l / S != B.l / S) return A.l / S < B.l / S;",
									"    return A.r > B.r;",
									"}",
									"",
									"int nc3(int n) {",
									"    return (n * (n - 1) * (n - 2)) / 6;",
									"}",
									"",
									"int ans = 0;",
									"int a[N + 1];",
									"int freq[N + 1];",
									"",
									"void add(int x) {",
									"    ans -= nc3(freq[x]);",
									"    freq[x]++;",
									"    ans += nc3(freq[x]);",
									"}",
									"",
									"void remove(int x) {",
									"    ans -= nc3(freq[x]);",
									"    freq[x]--;",
									"    ans += nc3(freq[x]);",
									"}",
									"",
									"void harshit() {",
									"    int n, q; cin >> n >> q;",
									"    // V<int> a(n);",
									"    // cin >> a;",
									"    for (int i = 0; i < n; i++) {",
									"        cin >> a[i];",
									"    }",
									"    vector<Query> queries(q);",
									"    for (int i = 0; i < q; ++i) {",
									"        cin >> queries[i].l >> queries[i].r;",
									"        queries[i].l--;",
									"        queries[i].r--;",
									"        queries[i].id = i;",
									"    }",
									"",
									"    sort(queries.begin(), queries.end(), cmp);",
									"    vector<int> result(q);",
									"",
									"    for (int i = 0, L = 1, R = 0; i < q; ++i) {",
									"        while (R < queries[i].r) add(a[++R]);",
									"        while (L > queries[i].l) add(a[--L]);",
									"        while (R > queries[i].r) remove(a[R--]);",
									"        while (L < queries[i].l) remove(a[L++]);",
									"        result[queries[i].id] = ans;",
									"    }",
									"",
									"    for (int i = 0; i < q; ++i) {",
									"        cout << result[i] << endl;",
									"    }",
									"}"
								],
								"description": "Mo's Algorithm for Range Query Processing with Sorting of Queries"
							},
							"PowerFunction": {
        "prefix": "powr",
        "body": [
            "int power(int x, int n, int mod) {",
            "    if (n == 0) {",
            "        return 1;",
            "    }",
            "    if (n % 2 == 1) {",
            "        return (power(x, n - 1, mod) * x) % mod;",
            "    }",
            "    int ans = power(x, n / 2, mod);",
            "    return (ans * ans) % mod;",
            "}"
        ],
        "description": "Power function using recursion and modular arithmetic"
    },
	"SieveFunction": {
        "prefix": "sie",
        "body": [
            "vector<int> F;",
            "",
            "void Pre() {",
            "    const int N = 1e6 + 5;",
            "    vector<bool> P(N, true);",
            "    P[0] = false;",
            "    P[1] = false;",
            "",
            "    for (int i = 2; i * i <= N; i++) {",
            "        if (P[i]) {",
            "            for (int j = i * i; j < N; j += i) {",
            "                P[j] = false;",
            "            }",
            "        }",
            "    }",
            "    for (int i = 2; i < N; i++) {",
            "        if (P[i]) {",
            "            F.push_back(i);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve of Eratosthenes to generate primes"
    }
					
						
					
}
